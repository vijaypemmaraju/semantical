---
import Layout from "../layouts/Layout.astro";
import Card from "../components/Card.astro";

import { GET } from "./word.json";
---

<script>
  import ForceGraph, { type ForceGraphInstance } from "force-graph";
  import ky from "ky";
  import copy from "copy-to-clipboard";
  import isMobile from "../util/isMobile";

  const [word, goal] = await ky
    .get("./start.json", { timeout: 30000 })
    .json<string[]>();
  document.getElementById("goal")!.innerText = `Find ${goal}`;
  let nodes: { id: string }[] = [];
  let links: { source: string; target: string }[] = [];
  let Graph: ForceGraphInstance;
  let lock = false;
  let clicks = 0;
  let won = false;
  let capturing = false;
  const onNodeClick = async (node: any) => {
    node.clicked = true;
    Graph.centerAt(node.x, node.y, 1000);
    const temp = node.id;
    node.loading = true;
    clicks++;
    let data;
    try {
      data = await ky
        .get(`./word.json?word=${temp}`, { timeout: 30000, retry: 3 })
        .json<{
          words: string[];
        }>();
    } catch (e) {
      console.error(e);
      node.loading = false;
      node.error = true;
      lock = false;
      return [];
    }
    node.loading = false;
    node.error = false;

    if (lock) {
      await new Promise((resolve) => {
        const interval = setInterval(() => {
          if (!lock) {
            clearInterval(interval);
            resolve(null);
          }
        }, 100);
      });
    }
    lock = true;

    let newNodes: { id: string }[] = [];
    data.words.forEach((word: string) => {
      const newNode = { id: word };
      newNodes.push(newNode);
      nodes.push(newNode);
    });
    // dedupe
    nodes = nodes.filter(
      (node, index, self) => self.findIndex((n) => n.id === node.id) === index
    );
    // add links
    links = links.concat(
      data.words.map((word: string) => ({ source: node.id, target: word }))
    );
    // if (true) {
    if (nodes.find((n) => n.id === goal && !won)) {
      Graph.zoomToFit(1000, isMobile() ? 100 : 250);
      capturing = true;
      let file: File;
      Graph.linkWidth(3);
      setTimeout(async () => {
        const originalCanvas = document.querySelector("canvas")!;
        const heightToUse = isMobile() ? originalCanvas.height / 2 : originalCanvas.height;
        const desiredWidth = 1500;
        const desiredHeight = desiredWidth * (heightToUse / originalCanvas.width);
        let startingY = isMobile() ? originalCanvas.height / 4 : 0;
        let endingY = isMobile() ? 3 * originalCanvas.height / 4 : originalCanvas.height;
        const canvas = document.createElement("canvas");
        canvas.width = desiredWidth;
        canvas.height = desiredHeight;
        // draw background
        const context = canvas
          .getContext("2d")!;

          context.fillStyle = "#1d232a";
          context.fillRect(0, 0, canvas.width, canvas.height);
        context
          .drawImage(
            originalCanvas,
            0,
            startingY,
            originalCanvas.width,
            endingY,
            0,
            0,
            desiredWidth,
            desiredHeight
          );
        const imageUrl = canvas!.toDataURL("image/png");
        document.getElementById("result")!.setAttribute("src", imageUrl);
        const blob = await (
          await fetch(document.getElementById("result")?.getAttribute("src")!)
        ).blob();
        file = new File([blob], "graph.png", { type: blob.type });
        capturing = false;
        Graph.linkWidth(6);
      }, 1000);
      won = true;
      const dialog = document.getElementById("dialog") as HTMLDialogElement;
      dialog.showModal();
      document.getElementById("info")!.innerText =
        `You found ${goal} in ${clicks} clicks!`;

      document.getElementById("share")!.addEventListener("click", async () => {
        let text = `semantical.fun - I found today's word in ${clicks} clicks!`;
        if (isMobile() && navigator.share) {
          navigator.share({
            title: "I found the word!",
            text,
            files: [file],
          });
        } else {
          console.log("copying to clipboard", text);
          setTimeout(() => copy(text), 0);
          const div = document.createElement("div");
          div.innerHTML = `<div role="alert" class="alert alert-info absolute top-0 right-0 m-4 p-4 bg-blue-100 text-blue-900 rounded-lg flex items-center space-x-2 w-[50vw]">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
      <span>Copied to clipboard.</span>
    </div>`;

          document.querySelector("main")!.appendChild(div);
          setTimeout(() => {
            div.remove();
          }, 3000);
        }
      });
    }
    Graph.graphData({
      nodes,
      links,
    });
    lock = false;

    return newNodes;
  };

  interface NodeObject {
    id: string;
    loading?: boolean;
    hover?: boolean;
  }

  const nodesById: { [id: string]: NodeObject } = {};

  ky.get("./word.json", {
    searchParams: { word: word },
    timeout: 30000,
    retry: 3,
  })
    .then((res) => res.json<{ words: string[] }>())
    .then((data) => {
      nodes = data.words.map((word) => ({ id: word }));
      links = nodes.map((node) => ({ source: word, target: node.id }));
      nodes.push({ id: word });
      nodes = nodes.filter(
        (node, index, self) => self.findIndex((n) => n.id === node.id) === index
      );
      Graph = ForceGraph()(document.getElementById("graph")!)
        .graphData({
          nodes,
          links,
        })
        .nodeId("id")
        .nodeAutoColorBy("id")
        .nodeCanvasObject((node: any, ctx, globalScale) => {
          const label = node.id;
          const fontSize = 18;
          ctx.font = `${fontSize}px Sans-Serif`;
          const textWidth = ctx.measureText(label).width;
          const bckgDimensions = [textWidth, fontSize].map(
            (n) => n + fontSize * 0.8
          ); // some padding

          if (node.hover && !won) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
          } else {
            ctx.fillStyle = "rgba(50, 50, 50, 0.8)";
          }
          ctx.fillRect(
            node.x! - bckgDimensions[0] / 2,
            node.y! - bckgDimensions[1] / 2,
            bckgDimensions[0],
            bckgDimensions[1]
          );
          // draw border around rect
          if (node.id === goal) {
            ctx.strokeStyle = "rgba(255, 215, 0, 0.8)";
          } else if (node.id === word) {
            ctx.strokeStyle = "rgba(55, 255, 55, 0.8)";
          } else {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
          }
          ctx.strokeRect(
            node.x! - bckgDimensions[0] / 2,
            node.y! - bckgDimensions[1] / 2,
            bckgDimensions[0],
            bckgDimensions[1]
          );

          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = node.clicked
            ? "rgba(138, 128, 128, 0.8)"
            : node.color;
          ctx.fillStyle = node.error ? "rgba(255, 0, 0, 0.8)" : ctx.fillStyle;
          if (node.loading) {
            const currentTime = Date.now();
            ctx.beginPath();
            ctx.arc(
              node.x,
              node.y,
              5,
              (currentTime / 100) % (2 * Math.PI),
              ((currentTime / 100) % (2 * Math.PI)) + Math.PI
            );
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
          } else if (!capturing) {
            ctx.fillText(label, node.x, node.y);
          }
          nodesById[node.id] = node;
          node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
        })
        .onNodeClick(onNodeClick)
        .linkWidth(6)
        .zoom(/* check mobile */ window.innerWidth < 600 ? 1.5 : 1)
        .linkColor(() => "rgba(128, 128, 256, 0.2)")
        .linkDirectionalParticles(2)
        .linkCurvature(0.25)
        // .d3AlphaDecay(0)
        // .d3VelocityDecay(0.9)
        // .enableNodeDrag(false)
        .onNodeHover((node: any, previousNode: any) => {
          if (node) {
            node.hover = true;
          }
          if (previousNode) {
            previousNode.hover = false;
          }
        })
        .onNodeDragEnd((node, translate) => {
          console.log(node, translate);
          // if translate is small enough, consider it a click
          if (Math.abs(translate.x) < 10 && Math.abs(translate.y) < 10) {
            onNodeClick(node);
          }
        })
        .linkCanvasObjectMode(() => "after")
        .nodePointerAreaPaint((node: any, color, ctx) => {
          ctx.fillStyle = color;
          const bckgDimensions = node.__bckgDimensions;
          bckgDimensions &&
            ctx.fillRect(
              node.x - bckgDimensions[0] / 2,
              node.y - bckgDimensions[1] / 2,
              bckgDimensions[0],
              bckgDimensions[1]
            );
        });

      Graph.d3Force("link")?.distance(() => {
        return 125;
      });
      Graph.d3Force("charge")!.strength(-100);
      Graph.d3Force("center", null);
    });

  // perform a BFS to get the graph
  const bfs = () => {
    setTimeout(async () => {
      let visited = new Set<string>();
      let current = nodesById[word];
      let queue = [current];
      while (queue.length > 0) {
        current = queue.shift()!;
        console.log(current);
        if (visited.has(current.id)) {
          continue;
        }
        visited.add(current.id);
        const newNodes = await onNodeClick(current);
        console.log("newNodes", newNodes);
        await new Promise((resolve) => {
          setTimeout(async () => {
            for (let node of newNodes) {
              let nodeById = nodesById[node.id];
              while (!nodeById) {
                nodeById = nodesById[node.id];
                await new Promise((resolve) => {
                  setTimeout(() => {
                    resolve(null);
                  }, 100);
                });
              }
              queue.push(nodeById);
            }
            resolve(null);
          }, 0);
        });
      }
    }, 5000);
  };
  (window as any).bfs = bfs;
  // bfs();
</script>

<Layout title="Semantical">
  <main>
    <h1 class="absolute p-4 text-3xl text-primary" id="goal"></h1>
    <div id="graph">
      <div class="w-[100vw] h-[100vh] flex items-center justify-center">
        <span class="loading loading-spinner loading-lg"></span>
      </div>
    </div>
    <dialog id="dialog" class="modal">
      <div class="modal-box">
        <h3 class="font-bold text-lg">You win!</h3>
        <p id="info" class="py-4"></p>
        <img id="result" />
        <div class="modal-action">
          <form method="dialog">
            <button id="share" class="btn btn-primary">Share</button>
          </form>
        </div>
      </div>
    </dialog>

    <style>
      main {
        margin: auto;
        padding: 0rem;
        width: 100vw;
        height: 100vh;
        color: white;
        font-size: 20px;
        line-height: 1.6;
      }
    </style>
  </main>
</Layout>
